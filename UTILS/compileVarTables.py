#!/usr/bin/env python

import pathlib, re, math

lineParseRegex = re.compile(r'^[\t ]*(?!#|$)(?P<type>\w+)[\t ]+\[(?P<flags>\w*)\][\t ]+(?P<name>\w+)[\t ]+(?P<value>.*)$', re.MULTILINE)
fxpRegex = re.compile(r'^fxp(?P<fracBits>\d+)')

parseNum = lambda x : float(x) if "." in x else int(x, base=0)

getByte = lambda x, y : (x >> (y * 8)) & 0xFF

NTSC_FRAMERATE = (236250000 / 11) / 4 / 89341.5
PAL_FRAMERATE = (26601712.5) / 5 / 106392

def generateCNumArray(num : int|float, source : dict, maxNum : int = None) -> tuple:
	if not maxNum:
		maxNum = num

	if re.match(fxpRegex, source['type']):
		num *= 2 ** int(re.match(fxpRegex, source['type'])['fracBits'])	# Convert to fixed point
		maxNum *= 2 ** int(re.match(fxpRegex, source['type'])['fracBits'])

	if 'r' in source['flags']:	# Division
		ntscVal = num / NTSC_FRAMERATE
		palVal = num / PAL_FRAMERATE
		maxVal = maxNum / PAL_FRAMERATE		# Maximum result of division
	elif 'R' in source['flags']:	# Multiplication
		ntscVal = num * NTSC_FRAMERATE
		palVal = num * PAL_FRAMERATE
		maxVal = maxNum * NTSC_FRAMERATE	# Maximum result of division
	else:
		ntscVal = palVal = num
		maxVal = maxNum

	bitCount = math.ceil(math.log2(abs(maxVal)) / 8) * 8
	maxVal = 2 ** bitCount



	if (num < 0):
		ntscVal = maxVal - abs(ntscVal)
		palVal = maxVal - abs(palVal)

	return (
		(
			round(ntscVal),
			round((maxVal - ntscVal) if 'g' in source['flags'] else ntscVal),
		), (
			round(palVal),
			round((maxVal - palVal) if 'g' in source['flags'] else palVal),
		)
	)


def generateCTable(source : dict) -> str:
	comment = ""
	if source['flags'] == 'g':
		value = generateCNumArray(parseNum(source['value']), source)
		numTable = value[0]
		comment = "// Depends on gravity"
	elif source['flags'] == 'm':
		values = [parseNum(i) for i in source['value'].split()]
		values = [generateCNumArray(i, source, max(values)) for i in values]
		numTable = (values[0][0][0], values[1][0][0])
		comment = "// Depends on mini"
	elif source['flags'] == 'r' or source['flags'] == 'R':
		value = generateCNumArray(parseNum(source['value']), source)
		numTable = (value[0][0], value[1][0])
		comment = "// Depends on framerate"
	elif 'm' in source['flags']:
		values = [parseNum(i) for i in source['value'].split()]
		values = [generateCNumArray(i, source, max(values)) for i in values]
		numTable = (*values[0][0], *values[1][0], *values[0][1], *values[1][1])
	else:
		value = generateCNumArray(parseNum(source['value']), source)
		numTable = (*value[0], *value[0], *value[1], *value[1])

	size = math.ceil(math.log2(max(numTable)) / 8) * 8
	
	if (size == 8):
		return (comment + '\n' if len(comment) else '') + f'uint8_t {source['name']}[] = {{{", ".join(f"0x{i:02X}" for i in numTable)}}};\n'
	elif (size == 16):
		outString = comment + '\n' if len(comment) else ''
		outString += f'uint8_t {source['name']}_lo[] = {{{", ".join(f"0x{getByte(i, 0):02X}" for i in numTable)}}};\n'
		outString += f'uint8_t {source['name']}_hi[] = {{{", ".join(f"0x{getByte(i, 1):02X}" for i in numTable)}}};\n'
		return outString
	elif (size == 24 or size == 32):
		outString = comment + '\n' if len(comment) else ''
		outString += f'uint8_t {source['name']}_lo[] = {{{", ".join(f"0x{getByte(i, 0):02X}" for i in numTable)}}};\n'
		outString += f'uint8_t {source['name']}_md[] = {{{", ".join(f"0x{getByte(i, 1):02X}" for i in numTable)}}};\n'
		outString += f'uint8_t {source['name']}_hi[] = {{{", ".join(f"0x{getByte(i, 2):02X}" for i in numTable)}}};\n'
		if (size == 32):
			outString += f'uint8_t {source['name']}_ex[] = {{{", ".join(f"0x{getByte(i, 3):02X}" for i in numTable)}}};\n'
		return outString
	print(f"Table integer size {size} is invalid! Full table: {numTable}, happened with {source}")

	return f""


if __name__ == "__main__":
	import sys, argparse
	parser = argparse.ArgumentParser()
	parser.add_argument("input", nargs=argparse.REMAINDER)
	args = parser.parse_args()

	rootPath = pathlib.Path(sys.path[0]).parent.resolve()

	for filename in args.input:
		realFilename = rootPath / filename
		outFilename = realFilename.parent / (realFilename.stem+".cmp.h")
		
		outString = ["// This file was generated by compileVarTables.py\n\n"]

		for line in re.finditer(lineParseRegex, realFilename.read_text()):
			outString.append(generateCTable(line.groupdict()))

		outFilename.write_text("\n".join(outString))